[[11, 12, 13, 14, 15, 16],[21, 22, 23, 24, 25, 26],[31, 32, 33, 34, 35, 36],[41, 42, 43, 44, 45, 46],[51, 52, 53, 54, 55, 56], [61, 62, 63, 64, 65, 66], [71, 72, 73, 74, 75, 76]]
[[y, 12, 13, 14, 15, 16],[21, 22, 23, 24, 25, 26],[31, 32, 33, 34, 35, 36],[41, 42, 43, 44, 45, 46],[51, 52, 53, 54, 55, 56], [61, 62, 63, 64, 65, 66], [71, 72, 73, 74, 75, 76]]
evaluate_board([[11, 12, 13, 14, 15, 16],[21, 22, 23, 24, 25, 26],[31, 32, 33, 34, 35, 36],[y, 42, 43, 44, 45, 46],[51, 52, 53, 54, 55, 56], [61, 62, 63, 64, 65, 66], [71, 72, 73, 74, 75, 76]], y, r, X)


You're an expert programmer specialized in Prolog. You are going to help me write an AI for a game of Connect 4 using that language. 

To create a competent AI, we'll use the minimax algorithm with alpha-beta pruning. This will allow the AI to evaluate the best move by simulating future moves.
Here is an instance of the board : 
[[11, 12, 13, 14, 15, 16],[21, 22, 23, 24, 25, 26],[31, 32, 33, 34, 35, 36],[41, 42, 43, 44, 45, 46],[51, 52, 53, 54, 55, 56], [61, 62, 63, 64, 65, 66], [71, 72, 73, 74, 75, 76]]

We already have an heuristic function called evaluate_board(Board, Player1, Player2, Value) that yields the score of a board. Give the minimax code.

Here is our heuristic code :
get_element(Board, Row, Col, Element) :-
    nth1(Row, Board, RowList),
    nth1(Col, RowList, Element).

/** Obtention d'une slice du plateau (slice = 4 cases adjacentes) **/
get_slice(Board, Row, Col, Direction, Slice) :-
    findall(Element, (
        between(0, 3, Offset), % Itération sur 4 cases adjacentes à partir d une case de départ (x=Row, y=Col)
        (
            Direction = horizontal,
            NewCol is Col + Offset,
            get_element(Board, Row, NewCol, Element)
        ;
            Direction = vertical,
            NewRow is Row + Offset,
            get_element(Board, NewRow, Col, Element)
        ;
            Direction = diagonal,
            NewRow is Row + Offset,
            NewCol is Col + Offset,
            get_element(Board, NewRow, NewCol, Element)
        )
    ), Slice). % Ajout de l élement dans la slice

% Calcul le nombre de point rapporté par une slice pour Player 1
count_occurrences(Player1, Player2, Slice, Count) :-
    include(==(Player2), Slice, Filtered2),
    length(Filtered2, Count2),
    Count2==0,                  % un joueur doit être est le seul à avoir des pièces dans cet ensemble
    include(==(Player1), Slice, Filtered),
    length(Filtered, Count).

% Calcul le score pour Player1 sans prendre en compte son adversaire
evaluate_board_player(Board, Player1, Player2, Value) :-
    findall(Count, (    
        between(1, 7, Row),     
        between(1, 6, Col),
        get_slice(Board, Row, Col, horizontal, Slice), % Trouver toutes les slices horizontales
        count_occurrences(Player1, Player2, Slice, Count)
    ;                       
        between(1, 7, Row),     
        between(1, 6, Col),
        get_slice(Board, Row, Col, vertical, Slice), % Trouver toutes les slices verticales
        count_occurrences(Player1, Player2, Slice, Count)
    ;
        between(1, 7, Row),
        between(1, 6, Col),
        get_slice(Board, Row, Col, diagonal, Slice), % Trouver toutes les slices diagonales
        count_occurrences(Player1, Player2, Slice, Count)
    ), Counts),
    sum_list(Counts, Value).

% Calcul le score final de Player1
evaluate_board(Board, Player1, Player2, Value) :- 
    evaluate_board_player(Board, Player1, Player2, Value1),
    evaluate_board_player(Board, Player2, Player1, Value2),
    Value is Value1 - Value2.


   16 The following conventions are used in this program...
   18 Single letter variables represent:
   20 L - a list
   21 N - a number, position, index, or counter
   22 V - a value (usually a string)
   23 A - an accumulator
   24 H - the head of a list
   25 T - the tail of a list

   27 For this implementation, these single letter variables represent:
   29 P - a player number (1 or 2)
   30 B - the board (a 9 item list representing a 3x3 matrix)
   31     each "square" on the board can contain one of 3 values: x ,o, or e (for empty)
   32 S - the number of a square on the board (1 - 9)
   33 M - a mark on a square (x or o)
   34 E - the mark used to represent an empty square ('e').
   35 U - the utility value of a board position
   36 R - a random number
   37 D - the depth of the minimax search tree (for outputting utility values, and for debugging)

Here is the minimax code for tic-tac-toe, adapt this for our  Connect4.
%.......................................
% minimax
%.......................................
% The minimax algorithm always assumes an optimal opponent.

% For the opening move against an optimal player, the best minimax can ever hope for is a tie.
% So, technically speaking, any opening move is acceptable.
% Save the user the trouble of waiting  for the computer to search the entire minimax tree 
% by simply selecting a random square.

minimax(D,[E,E,E, E,E,E, E,E,E],M,S,U) :-   
    blank_mark(E),
    random_int_1n(9,S),
    !
    .

minimax(D,B,M,S,U) :-
    D2 is D + 1,
    moves(B,L),          %%% get the list of available moves
    !,
    best(D2,B,M,L,S,U),  %%% recursively determine the best available move
    !
    .

% if there are no more available moves, 
% then the minimax value is the utility of the given board position

minimax(D,B,M,S,U) :-
    utility(B,U)      
    .


%.......................................
% best
%.......................................
% determines the best move in a given list of moves by recursively calling minimax
%

% if there is only one move left in the list...

best(D,B,M,[S1],S,U) :-
    move(B,S1,M,B2),        %%% apply that move to the board,
    inverse_mark(M,M2), 
    !,  
    minimax(D,B2,M2,_S,U),  %%% then recursively search for the utility value of that move.
    S = S1, !,
    output_value(D,S,U),
    !
    .

% if there is more than one move in the list...

best(D,B,M,[S1|T],S,U) :-
    move(B,S1,M,B2),             %%% apply the first move (in the list) to the board,
    inverse_mark(M,M2), 
    !,
    minimax(D,B2,M2,_S,U1),      %%% recursively search for the utility value of that move,
    best(D,B,M,T,S2,U2),         %%% determine the best move of the remaining moves,
    output_value(D,S1,U1),      
    better(D,M,S1,U1,S2,U2,S,U)  %%% and choose the better of the two moves (based on their respective utility values)
    .


%.......................................
% better
%.......................................
% returns the better of two moves based on their respective utility values.
%
% if both moves have the same utility value, then one is chosen at random.

better(D,M,S1,U1,S2,U2,     S,U) :-
    maximizing(M),                     %%% if the player is maximizing
    U1 > U2,                           %%% then greater is better.
    S = S1,
    U = U1,
    !
    .

better(D,M,S1,U1,S2,U2,     S,U) :-
    minimizing(M),                     %%% if the player is minimizing,
    U1 < U2,                           %%% then lesser is better.
    S = S1,
    U = U1, 
    !
    .

better(D,M,S1,U1,S2,U2,     S,U) :-
    U1 == U2,                          %%% if moves have equal utility,
    random_int_1n(10,R),               %%% then pick one of them at random
    better2(D,R,M,S1,U1,S2,U2,S,U),    
    !
    .

better(D,M,S1,U1,S2,U2,     S,U) :-        %%% otherwise, second move is better
    S = S2,
    U = U2,
    !
    .


%.......................................
% better2
%.......................................
% randomly selects two squares of the same utility value given a single probability
%

better2(D,R,M,S1,U1,S2,U2,  S,U) :-
    R < 6,
    S = S1,
    U = U1, 
    !
    .

better2(D,R,M,S1,U1,S2,U2,  S,U) :-
    S = S2,
    U = U2,
    !
    .


output_value(D,S,U) :-
    D == 1,
    nl,
    write('Square '),
    write(S),
    write(', utility: '),
    write(U), !
    .
output_value(D,S,U) :- 
    true
    .